---
layout:	    post
title:      "[译|转]跳出两重循环"
subtitle:   "Python 高级特性之迭代抽象化"
date:       2016-08-13
author:     "kissg"
header-img: "img/2016-08-13-breaking-out-of-two-loops/covery.jpg"
comment:    true
tags:
    - 菜鸟成长日记
    - python
    - 译
    - 转
---

> 原文作者: Ned Batchelder\\
原文连接: [Breaking out of two loops](http://nedbatchelder.com//blog/201608/breaking_out_of_two_loops.html)\\
译者：kissg(赵喧典)\\
本文最先发表于微信公众号"编程派"，是本人在 PythonTG 翻译组的译文，相当于自我转载。[编程派地址](http://codingpy.com/article/breaking-out-of-two-loops/)，如需转载，请联系微信公众号"编程派"获得授权。转载时注明来源，作者及原文链接。


一个普遍存在的问题是，如何立即跳出嵌套的两重循环？例如，要检验字符串中是否存在相同的字符，如何在找到一对相同的字符之后就停止循环？经典的做法是，写一个两重嵌套循环，对字符串的索引进行迭代：

```python
s = "a string to examine"
for i in range(len(s)):
    for j in range(i+1, len(s)):
        if s[i] == s[j]:
            answer = (i, j)
            break   # 如何 break 两次呢???
```

此处，我们用两重循环来生成用于检验的两个索引。当条件满足时，我们希望能同时结束这两重循环。

对此，有一些常见的方法。但我个人很不喜欢它们：

- 将循环放在一个函数中进行，利用函数返回来跳出循环。但这样的做法不尽如人意，因为循环可能不适合重构为一个新的函数，也许你需要在循环的过程中访问其他代码。
- 抛出异常，并在两重循环之外捕获它。这是把异常当作 goto 语句来用了。但是这里并没有异常的条件，只是变向地利用了异常机制。
- 使用布尔变量来标记循环的结束，并在外循环中检查变量值以执行第二次 break 操作。该方法毫无技术成分，某些情况下可能是有效的，但大多数情况下只造成计算资源浪费，程序效率不高 (noise and bookkeeping)。

我更偏向于使用的方法，也是我在 PyCon 2013 上提到的一种方法，[更自然地循环](http://nedbatchelder.com/text/iter.html)，就是将两重循环写成一重循环，然后简单地跳出循环。

这需要花更多的功夫在循环上，但对于抽象化迭代过程是一次很好的练习。这正是 Python 非常擅长的，但人们也很容易忽视 Python 的这一特点，而把它当作一般的语言来使用，不能发挥循环抽象的优势。

让我们重新考虑这个问题。真的需要两重循环吗？写代码之前，不妨再仔细看一遍描述：

> 要检验字符串中是否存在相同的字符，如何在找到一对相同的字符之后就停止循环？

在这描述中，我并没有看出两重循环的意味。事实上，只需要对索引对进行一重循环就可以了。写法如下：

```python
def unique_pairs(n):
    """在 range(n) 范围内生成索引对"""
    for i in range(n):
        for j in range(i+1, n):
            yield i, j

s = "a string to examine"
for i, j in unique_pairs(len(s)):
    if s[i] == s[j]:
        answer = (i, j)
        break
```

此处，我们写了一个生成器用于生成需要的索引对。现在，我们的循环就成了对索引对的一重循环，而不是对索引的两重循环。两重循环依然存在，只是被抽象了出去，移到了 unique\_pairs 生成器内部。

这使我们的代码更贴近自然语言的描述。还应注意到，我们不用再写两次 len(s) 了，这其实是原代码需要重构的另一个标志。而且，如果在其他地方也需要这样迭代的话，还能复用 unique\_pairs 生成器。但是要记住，复用并不是写一个函数的必要条件。

我知道这个方法有点奇异。但它真的是最佳的解决方案了。如果你仍旧停留在两重循环阶段，多想想你脑海中是如何组织程序的。事实上，当你尝试着一次性跳出两重循环，从某种意义上来说，这两重循环就是一回事了，而不是两回事。将二重性隐藏到一个生成器内部，就可以如你所想的那样组织代码了。

Python 有着强大的抽象化工具，包括生成器和其他能抽象迭代过程的技术。如果你想了解更多，我的演说[更自然地循环](http://nedbatchelder.com/text/iter.html)有更多的细节。
