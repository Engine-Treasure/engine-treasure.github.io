递归能解决的问题, 循环都能解决. 反之亦然.

这句话真的正确吗? 可证吗?

如果迭代的过程可以用`栈`实现, 那么这句话就是正确的. 否则, 递归能实现的, 循环不一定能实现, 比如遍历一棵树.

当给定一个栈, 不使用递归的循环无疑能很好地模拟递归的过程. 那么递归呢, 它真能解决任何循环能解决的问题吗?

答案是肯定的. 在函数式编程语言中, 用递归实现循环是司空见惯的事.

那么函数式编程语言(没有赋值语句)是否具有与命令式编程相同的算法表现呢? (命令式编程语言可以模拟函数式编程语言)

答案也是肯定的. 它们都具有图灵完全性. 比如说, 许多函数式编程语言的解释器都是用C语言写的.

这与`邱奇-图灵论题(Church Turing Thesis)`紧密相连. 邱奇用一个函数式的编程语言模型(lambda 演算), 而图灵则用一个规则模型(图灵机). `邱奇-图灵论题`证明了他们二者是等效的.

栈溢出又会怎样? 这是递归才有的问题. 我的观点是, 不同的解决方案是不同的, 细微的差别也可能是灾难性的. 尤其是对于你不了解的东西, 草草地为不同的方法划上等号是件很危险的事情.

在用递归实现循环的语言中, 通常在编译的过程中借助`尾递归(Tail Recuision)`实现递归的优化 —— 因此不用借助额外的栈帧, 也不会有栈溢出.

下面是一段`Scheme`代码写的 http server, 它就不会耗尽栈的资源. 这由语言标准提供保障.
```Scheme
(define (server-loop)
    (let ((request (get-request)))
    (handle-request request))
    (server-loop))
```

但是, 在栈被用于实际存储的情况下, 用尾递归实现递归优化是不可能的 —— 比如树的遍历, 或者快速排序. 循环版本的快速排序必须手动模拟, 创建一个栈.





